# TestDrivenDevelopment
테스트 주도개발(켄트벡 저)책 정리
- 웹 개발(그 중에서도 백엔드)에 관심이 생기고, 무턱대고 여러 자료를 찾아보고 클론코딩할 만한 책도 몇 권 훑다보니 테스트의 중요서에 대해 하나같이 역설하는 것을 발견했다!
- 그래서 테스트와 관련해서 junit의 사용에 치우친게 아니라 소프트웨어 개발에 있어 테스트의 중요성을 알 수 있을 법한 책을 찾던 중 해당 책을 찾게 되어 공부할 예정이다!

----
[Chapter1]() - 테스트 주도 개발이 어떤 흐름으로 이루어지는 예제를 통해 알아봄  
[Chapter3]() - 테스트 주도 개발의 패턴에 대해 자세히 알아봄
#### 2부는 테스트 툴에 대한 내용이라 당장은 생략함

----
# Chapter1

>Theme0
- **TDD Rhythm**
  - 간단한 테스트를 하나 추가한다
  - 모든 테스트를 실행하고 추가한 것이 실패하는지 확인한다
  - 코드를 조금 수정한다(죄악을 범해서라도)
  - 모든 테스트를 실행하고 전부 성공하는지 확인한다
  - 리팩토링을 통해 중복을 제거한다(올바르게 만든다)
- 의문 : 얼마나 잦은 테스트를 실행해야 하는가?? 
- 좀 더 간단히 말하면
  - 테스트 작성
  - 컴파일되게 하기
  - 실패하는지 확인
  - 실행하게 만듦
  - 중복 제거
<br><br>
>Theme1
- 객체를 만들면서 시작되는 것이 아니라 테스트를 만들면서 시작된다
  - 어떤 객체가 필요할까? -> 어떤 테스트가 필요할까?(테스트 목록을 작성하자)
- 테스트를 작성할 때는 메서드의 완벽한 인터페이스를 상상하자
  - 인터페이스를 상상한다는 것은 구현을 의미하는 것이 아니다!
  - OOP에서 중요한건 구현이 아니라 추상화와 역할의 분배이고, TDD에서 중요한건 통과되는 테스트를 우선 만드는 것이다!
  - 책의 예제
    ```java
      public void testMultiplication(){
        Dollar five = new Dollar(5);
        five.times(2);
        assertEquals(10, five.amount);
      }
    // 테스트 에러 : Dollar 클래스 없음, 생성자 없음, 
    // times메서드 없음, amount 필드 없음
      ```
    다음과 같이 Dollar 객체나 그 메서드, 필드의 세부 구현 없이 단지 화폐의 계산이 다음과 같이 이루어질 것이다는 인터페이스만 완벽히 상상한다
  - 이 문제를 해결하기 위해 Dollar객체를 만들고, times 함수를 추가하고(구현 없이 시그니처만), amount 필드를 추가하면 컴파일이 된다!
  - 하지만 그 뒤에 assertEquals()의 결과로 error가 발생한다. 컴파일 통과시키기 테스트 -> 제대로 된 결과 도출하기 테스트 로 목적의 변화!
    - > 앞으로의 과정도 다음과 같을 것이다! 큰 문제 -> 작은 테스트 -> 다음 테스트 -> 다음 테스트  
        **난이도와 범위를 줄여나간다!**
  - 테스트를 해결하는 것은 또 다른 테스트를 만들어 내기도 한다!  
    ex) 위의 통화의 곱하기 테스트를 작성하고나니 Dollar의 값이 변한다 -> Dollar부작용 테스트를 목록에 추가!

> Theme2
- 테스트를 가능한 빨리 통과하기 = 죄악을 범하더라도!
  - 가짜로 구현하기 -> 원하는 결과를 그대로 반환하는 메서드 구현(retrun 원하는 값)
  - 실제 구현 사용하기
  - 삼각측량  

>Theme3
- 특정 디자인 패턴은 특정 메서드 구현을 암시한다 ex) 값 객체 패턴에서는 equals()를 구현할 필요가 있다
- 삼각측량 : 라디오 신호를 두 수신국이 감지하고 있을 때, 수신국 사이의 거리와 각 수신국이 신호의 방향을 알고 있다면, 이 정보들 만으로 충분히 신호의 거리와 방위를 알 수 있다
- 어떤 테스트를 통과하게 하는 것 만으로는 이게 정확한 구현인지 감이 오지 않을 때, 인자만 다른 다른 테스트를 추가하는 것!

>Theme4
- 테스트는 일련의 오퍼레이션 보다는 참인 명제에 대한 단언들이 더 낫다
  ```java
  public void testMultiplication(){
  Dollar five = new Dollar(5);
  Dollar product = five.times(2);
  assertEquals(10, product);
  // 보다는
  Dollar five = new Dollar(5);
  assertEquals(new Dollar(10), five.times(2));
  }
  ```
>Theme9
- TDD는 조정해 나가는 과정이다. 보폭이 좁은가? 보폭을 넓게 가지자. 보폭이 넓은가? 보폭을 좁게 가지자!
- 이 책의 저자는 답답할 정도로 좁은 보폭으로 할 일을 추가하고, 수정한다. 리팩토링 과정에서는 중복을 제거하기 위해 중복을 최대한 같게 만들고 그를 상위 부분으로 이동시킨다
- _**이런 과정이 필수라는 것이 아니라. 이런 좁은 보폭으로도 개발 할 줄 알아야 한다는 뜻이다!**_

>Theme10
- 신뢰할만한 테스트를 만들었다면, 어떤 변화가 코드의 결과에 어떤 영향을 줄지 생각을 해보는 것이 아니라 코드에게 직접 물어보는 것이(변경에 대해 테스트 코드를 실행해 보는것)빠를 때가 있다!
- 이미 테스트가 실패한 상황에서는 새로운 테스트를 추가하는 것을 지양해야 한다

>Theme12
- 오브젝트를 공부하면서 어떤 역할은 역할을 수행하기 위해 필요한 데이터를 가장 잘 알고 있는 객체에게 부여해야 된다고 배웠다
- 여기서도 그것을 경험적으로 설명하는데, 환율을 고려한 화폐의 덧셈을 테스트하기 위해 메서드를 상상할 때, 그것을 기존의 Money객체가 아닌 새로운 Bank객체(돈, 환율 전문가) 상상해서 테스트 코드를 작성함

>Theme13
- 코드 예제를 보면서 새로운 클래스들이 생기고 그들간의 관계가 이해하기 어려워져서 찾아보니 '컴퍼지트 패턴(Composite)'을 이용함을 알았다
  - 컴퍼지트 패턴은 단일 객체와 그 객체들을 가지는 집합 객체를 같은 타입으로 취급하며, 트리 구조로 객체들을 엮는 패턴을 의미한다
  - 장 : 객체들이 모두 같은 타입으로 취급 됨 -> 새로운 클래스 추가 용이(형변환에 대한 고려 불필요)
  - 단 : 설계 일반화 -> 객체간의 구분, 제약이 힘들다(내가 처음 보고 객체들간의 구분이 힘들었던 이유!!)
  - 언제 사용? : 객체들 간 계층구조를 표현할 때, 클라이언트가 단일 객체와 집합 객체를 구분하지 않고 사용하고자 할 때
  ![CompositePattern](./img/CompositePattern.png)
  - 해당 그림의 Composite와 Component(interface)의 관계를 보면 Composite는 Component를 구현(implements)하는 Leaf(단독 객체), Composite(집합 객체)를 자식으로 가질 수 있다!

>Theme18
- xUnit : JUnit이 대표적인데, 테스트 툴을 통칭하는 것이다
- 해당 Theme으로부터 시작되는 2부 내용은 xUnit, 즉 테스트 툴에 대한 내용으로 지금 당장은 필요한 내용이 아니라고 판단하고 3부로 바로 넘어갈 예정


# Chapter 3
- 테스트 주도 개발의 패턴

>Theme25
- 테스트를 하기 전에 고려해야 할 기본적인 전략
  - 테스트한다는 것은 무슨 뜻인가?
  - 테스트는 언제 해야 하는가?
  - 테스트할 로직을 어떻게 고를 것인가?
  - 테스트할 데이터를 어떻게 고를 것인가?
- 테스트(명사) : 테스트(명사)는 테스트(동사)와는 다르다. 후자가 어떤 버튼을 통해 확인해보는 과정이라고 하면 전자는 자동화된 일련의 과정을 의미한다! 우리는 전자를 추구해야 한다
- 격리된 테스트 : 각각의 테스트는 작은 기능에 대해 격리되어 진행되어야 한다. 즉, 어떤 테스트의 실패가 다른 테스트에 영향을 끼치지 않아야 한다!  
->   오브젝트에서는 시스템을 결합도는 낮고 응집도는 높은 객체들의 모음으로 구성하는게 좋다고 했다! 여기서 추구하는 테스트이 모습이 딱 그런모습인것같다!!!
- 코드를 작성하기 전에 이렇게 작동해야 한다, 이런 결과가 나와야 한다 라는 테스트를 먼저 작성한다! = 테스트 우선
- 테스트와 데이터 : 테스트에 사용하는 데이터는 테스트를 읽을 때, 따라가기 쉬운 데이터를 사용해야 한다. 즉, 2를 사용하는데 의미적으로 이유가 있는게 아니면 테스트 데이터에 1을 사용하는 식이다
- 명확한 데이터 : 내가 기능적으로 테스트하고자 하는 바가 무엇인지 명확히 보여줄 수 있는 데이터를 사용한다! -> ex) 환율 계산 함수를 테스트 할때, assertEqual()의 매개 변수로 환율이 적용된 값을 바로 테스트 하는 것이 아니라 환율으 계산하는 식을 상수식으로 적어놓는 식으로 내가 테스트 하고자 하는 바를 명확힐 알 수 있게 한다

>Theme26
- 회귀 테스트 : 시스템 장애가 보고되면 1. 해당 장애로 인해 실패하는 테스트 작성 2. 해당 테스트가 통과되면 장애를 해결했다고 볼 수 있는 테스트 작성

>Theme27
- **테스팅 패턴**
- 자식 테스트 : 지나치게 큰 테스트를 통과시키기 위해, 큰 테스트의 깨지는 부분에 해당하는 작은 테스트를 작성해서 통과되게 하라. 그 후에 다시 원래의 큰 테스트를 추가한다
- 모의 객체 : 비용이 많이 들거나 복잡한 리소스에 의존하는 객체에 대한 테스트를 해야 할 때, 모의 객체(Mock Object)를 사용하라. 데이터 베이스 등
- 셀프 션트 : 한 객체가 다른 객체와 올바르게 의사소통하는지 알아보기 위해서 테스트 대상이 되는 객체가 원래의 대화 상대가 아니라 테스트케이스와 대화 하도록 테스트해라.
- 로그 문자열 : 메시지의 호출 순서를 테스트 해야 한다고 해보자. 로그용 문자열을 가지고 있다가 메시지가 호출 될 때마다 문자열에 추가되도록 한다
- 크래시 테스트 더미 : 호출되지 않을 것 같은 에러를 테스트 하는 법 -> 실제 작업을 수행하지는 않고 해당 에러를 발생시키는 특수한 객체를 사용해 테스트한다

>Theme29
- **xUnit 패턴**
- 단언 : 불리언 수식을 작성해서 컴퓨터가 판단을 수행하도록 하라 -> assert()문
- 단언에 변수가 직접 테스트 되도록 하는 것은 바람직 하지 않다. 예를 들어, Contract의 인스턴스의 상태가 Running으로 변했는지 알아보는 테스트를 작성한다고 했을때  
assertEqual(contract.state, Running.state)를 하면 state의 구현에 의존적이므로 state의 구현의 변화에 취약해진다. 하지만 contract의 상태가 변할때, 변하는 시간이 기록된다는 사실을 이용하면  
assertEqual(contract.startDate(),...) 를 이용해 구현의 의존하지 않으면서도 테스트를 진행 할 수 있음!
- 픽스처 : 여러 테스트에서 공통으로 사용하는 객체는 어떻게 생서하는게 좋을까?
- 각 테스트의 지역 변수를 인스턴스 변수로 바꾸고, 각 테스트가 시작될 때 인스턴스를 초기화 하도록 한다
- 객체 세팅 코드 setUp()을 설정해 줄 수 있다
- 외부 픽스처 : setUp()과는 반대로 각 테스트가 끝나고 외부에서 가져온 파일을 닫는 등의 공통된 작업이 요구 될 때가 있다.  
이때는 tearDown()을 설정해 줄 수 있댜
- 테스트 네이밍 : testABCD의 형태를 가진다
- 예외 테스트 : 예외가 발생하는 것이 정상적인 경우에 대해 테스트 할 때는 예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않는 경우에 테스트를 실패하게 만든다.  
try catch 문 -> try단락의 끝에 fail()을 작성해서 테스트 하고자 하는 메서드가 호출된 뒤에 예외가 catch 되는게 아니면 fail()문이 호출되어 테스트가 실패하도록 한다
