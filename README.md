# TestDrivenDevelopment
테스트 주도개발(켄트벡 저)책 정리
- 웹 개발(그 중에서도 백엔드)에 관심이 생기고, 무턱대고 여러 자료를 찾아보고 클론코딩할 만한 책도 몇 권 훑다보니 테스트의 중요서에 대해 하나같이 역설하는 것을 발견했다!
- 그래서 테스트와 관련해서 junit의 사용에 치우친게 아니라 소프트웨어 개발에 있어 테스트의 중요성을 알 수 있을 법한 책을 찾던 중 해당 책을 찾게 되어 공부할 예정이다!

----
[Chapter1]()  

----
# Chapter1

>Theme0
- **TDD Rhythm**
  - 간단한 테스트를 하나 추가한다
  - 모든 테스트를 실행하고 추가한 것이 실패하는지 확인한다
  - 코드를 조금 수정한다(죄악을 범해서라도)
  - 모든 테스트를 실행하고 전부 성공하는지 확인한다
  - 리팩토링을 통해 중복을 제거한다(올바르게 만든다)
- 의문 : 얼마나 잦은 테스트를 실행해야 하는가?? 
- 좀 더 간단히 말하면
  - 테스트 작성
  - 컴파일되게 하기
  - 실패하는지 확인
  - 실행하게 만듦
  - 중복 제거
<br><br>
>Theme1
- 객체를 만들면서 시작되는 것이 아니라 테스트를 만들면서 시작된다
  - 어떤 객체가 필요할까? -> 어떤 테스트가 필요할까?(테스트 목록을 작성하자)
- 테스트를 작성할 때는 메서드의 완벽한 인터페이스를 상상하자
  - 인터페이스를 상상한다는 것은 구현을 의미하는 것이 아니다!
  - OOP에서 중요한건 구현이 아니라 추상화와 역할의 분배이고, TDD에서 중요한건 통과되는 테스트를 우선 만드는 것이다!
  - 책의 예제
    ```java
      public void testMultiplication(){
        Dollar five = new Dollar(5);
        five.times(2);
        assertEquals(10, five.amount);
      }
    // 테스트 에러 : Dollar 클래스 없음, 생성자 없음, 
    // times메서드 없음, amount 필드 없음
      ```
    다음과 같이 Dollar 객체나 그 메서드, 필드의 세부 구현 없이 단지 화폐의 계산이 다음과 같이 이루어질 것이다는 인터페이스만 완벽히 상상한다
  - 이 문제를 해결하기 위해 Dollar객체를 만들고, times 함수를 추가하고(구현 없이 시그니처만), amount 필드를 추가하면 컴파일이 된다!
  - 하지만 그 뒤에 assertEquals()의 결과로 error가 발생한다. 컴파일 통과시키기 테스트 -> 제대로 된 결과 도출하기 테스트 로 목적의 변화!
    - > 앞으로의 과정도 다음과 같을 것이다! 큰 문제 -> 작은 테스트 -> 다음 테스트 -> 다음 테스트  
        **난이도와 범위를 줄여나간다!**
  - 테스트를 해결하는 것은 또 다른 테스트를 만들어 내기도 한다!  
    ex) 위의 통화의 곱하기 테스트를 작성하고나니 Dollar의 값이 변한다 -> Dollar부작용 테스트를 목록에 추가!

> Theme2
- 테스트를 가능한 빨리 통과하기 = 죄악을 범하더라도!
  - 가짜로 구현하기 -> return 상수 등 원하는 결과를 반환하기 위해 가짜로 구현하는 방법!
  - 실제 구현 사용하기
  - 삼각측량  

>Theme3
- 특정 디자인 패턴은 특정 메서드 구현을 암시한다 ex) 값 객체 패턴에서는 equals()를 구현할 필요가 있다
- 삼각측량 : 라디오 신호를 두 수신국이 감지하고 있을 때, 수신국 사이의 거리와 각 수신국이 신호의 방향을 알고 있다면, 이 정보들 만으로 충분히 신호의 거리와 방위를 알 수 있다
- 어떤 테스트를 통과하게 하는 것 만으로는 이게 정확한 구현인지 감이 오지 않을 때, 인자만 다른 다른 테스트를 추가하는 것!

>Theme4
- 테스트는 일련의 오퍼레이션 보다는 참인 명제에 대한 단언들이 더 낫다
  ```java
  public void testMultiplication(){
  Dollar five = new Dollar(5);
  Dollar product = five.times(2);
  assertEquals(10, product);
  // 보다는
  Dollar five = new Dollar(5);
  assertEquals(new Dollar(10), five.times(2));
  }
  ```
>Theme9
- TDD는 조정해 나가는 과정이다. 보폭이 좁은가? 보폭을 넓게 가지자. 보폭이 넓은가? 보폭을 좁게 가지자!
- 이 책의 저자는 답답할 정도로 좁은 보폭으로 할 일을 추가하고, 수정한다. 리팩토링 과정에서는 중복을 제거하기 위해 중복을 최대한 같게 만들고 그를 상위 부분으로 이동시킨다
- _**이런 과정이 필수라는 것이 아니라. 이런 좁은 보폭으로도 개발 할 줄 알아야 한다는 뜻이다!**_

>Theme10
- 신뢰할만한 테스트를 만들었다면, 어떤 변화가 코드의 결과에 어떤 영향을 줄지 생각을 해보는 것이 아니라 코드에게 직접 물어보는 것이(변경에 대해 테스트 코드를 실행해 보는것)빠를 때가 있다!
- 이미 테스트가 실패한 상황에서는 새로운 테스트를 추가하는 것을 지양해야 한다
- 
